package com.javahelp.model.user;

import org.junit.Before;
import org.junit.Test;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;

import java.util.Base64;
import java.util.Random;

/**
 * A testing file for UserPassword entity
 */
public class UserPasswordTest {

    /**
     * The current salt for the first user
     */
    private byte[] saltOne;

    /**
     * The current salt for the second user
     */
    private byte[] saltTwo;

    /**
     * The current given password of the first user
     */
    private byte[] passWord1;

    /**
     * The current given password of the second user
     */
    private byte[] passWord2;

    /**
     * Representation of the first user's password
     */
    private UserPassword user1Pass;

    /**
     * Representation of the second user's password
     */
    private UserPassword user2Pass;

    @Before
    public void setUp() {
        // New random object
        Random rand = new Random();

        // Current given 2 salts
        byte[] saltOne = {5, 6, 8, 2, 6, 4, 1};
        byte[] saltTwo = {7, 8, 9, 15, 22, 29, 3};

        // Current given 2 passwords
        byte[] passWord1 = {5, 6, 1, 8, 5, 6, 'a', '!', 6, 5};
        byte[] passWord2 = {'S', 'e', 'c', 'o', 'n', 'd'};

        // Add to their corresponding attributes
        this.saltOne = saltOne;
        this.saltTwo = saltTwo;
        this.passWord1 = passWord1;
        this.passWord2 = passWord2;

        /* Generate a random value for each of the salts and the passwords. This
        is done after assigning the values to attributes, so that no difference among
        passwords or salts could be generated by the Random rand object. */
        rand.nextBytes(saltOne);
        rand.nextBytes(saltTwo);
        rand.nextBytes(passWord1);
        rand.nextBytes(passWord2);

        // Initialize
        this.user1Pass = new UserPassword(saltOne, passWord1);
        this.user2Pass = new UserPassword(saltTwo, passWord2);
    }

    @Test(timeout = 50)
    public void testUserHashPassword(){
        Random rand = new Random();

        rand.nextBytes(passWord2);
        rand.nextBytes(passWord1);

        assertNotEquals(passWord2, user1Pass.getHash());
        assertEquals(passWord2, user2Pass.getHash());
    }

    @Test(timeout = 50)
    public void testUserSalt(){
        Random rand = new Random();
        byte[] password1 = {5, 6, 1, 8, 5, 6, 'a', '!', '6', 5};

        rand.nextBytes(password1);
        rand.nextBytes(saltTwo);

        assertNotEquals(password1, user1Pass.getSalt());
        assertEquals(saltTwo, user2Pass.getSalt());

        user1Pass.setSalt(password1);
        assertNotEquals("This is no longer the current salt of this user!",
                saltOne, user1Pass.getSalt());
    }

    @Test(timeout = 50)
    public void testSetHashPassword(){
        Random rand = new Random();
        byte[] newPass1 = {7, 1, 4};
        rand.nextBytes(newPass1);

        this.user1Pass.setHash(newPass1);
        assertEquals(newPass1, user1Pass.getHash());

        // Not updating the password yet
        byte[] newPass2 = {7, 1, 4, 2};
        rand.nextBytes(newPass2);

        assertNotEquals("The given password is not updated to the given password2 yet!",
                newPass2, user1Pass.getHash());

        // Until now
        user1Pass.setHash(newPass2);
        assertEquals(newPass2, user1Pass.getHash());
    }

    @Test(timeout = 50)
    public void testSetSalt(){
        Random rand = new Random();
        byte[] newSalt1 = {5, 6, 8, 2, 6, 4, 1, 3};
        rand.nextBytes(newSalt1);

        // Not update the Salt yet
        assertNotEquals("The current salt has not yet been updated to newSalt1!",
                newSalt1, user1Pass.getSalt());

        // Until now
        user1Pass.setSalt(newSalt1);
        assertEquals(newSalt1, user1Pass.getSalt());
    }

    @Test(timeout = 50)
    public void testGetBase64SaltHash(){
        byte[] combined = {5, 6, 8, 2, 6, 4, 1, 5, 6, 1, 8, 5, 6, 'a', '!', 6, 5};
        assertNotEquals(Base64.getEncoder().encodeToString(combined),
                user1Pass.getBase64SaltHash());
    }

    @Test
    public void testEncodeDecodeBase64() {
        Random r = new Random();
        for (int i = 0; i < 100; i++) {
            int saltLength = 1 + r.nextInt(31);
            byte[] salt = new byte[saltLength];
            int hashLength = 1 + r.nextInt(31);
            byte[] hash = new byte[hashLength];
            r.nextBytes(salt);
            r.nextBytes(hash);
            UserPassword base = new UserPassword(salt, hash);
            UserPassword encoded = new UserPassword(base.getBase64SaltHash());
            assertArrayEquals(base.getHash(), encoded.getHash());
            assertArrayEquals(base.getSalt(), encoded.getSalt());
        }
    }
}
