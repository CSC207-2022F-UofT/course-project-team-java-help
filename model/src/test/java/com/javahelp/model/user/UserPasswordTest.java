package com.javahelp.model.user;

import org.junit.Before;
import org.junit.Test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;

import java.util.Base64;
import java.util.Random;

/**
 * A testing file for UserPassword entity
 */
public class UserPasswordTest {

    /**
     * --- Attributes ---
     * rand - a variable of Random type to generate random byte[] representation of an input.
     * saltOne - the current salt for the first user
     * saltTwo - the current salt for the second user
     * passWord1 - the current given password of the first user
     * passWord2 - the current given password of the second user
     *
     * user1Pass - an object represents for the first user's password
     * user2Pass - an object represents for the second user's password
     * user1 - the first user
     * user2 - the second user
     */
    private Random rand;

    private byte[] saltOne;

    private byte[] saltTwo;

    private byte[] passWord1;

    private byte[] passWord2;

    private UserPassword user1Pass;

    private UserPassword user2Pass;

    @Before
    public void setUp() {
        // New random object
        this.rand = new Random();

        // Current given 2 salts
        byte[] saltOne = {5, 6, 8, 2, 6, 4, 1};
        byte[] saltTwo = {7, 8, 9, 15, 22, 29, 3};

        // Current given 2 passwords
        byte[] passWord1 = {5, 6, 1, 8, 5, 6, 'a', '!', 6, 5};
        byte[] passWord2 = {'S', 'e', 'c', 'o', 'n', 'd'};

        // Add to their corresponding attributes
        this.saltOne = saltOne;
        this.saltTwo = saltTwo;
        this.passWord1 = passWord1;
        this.passWord2 = passWord2;

        // Generate a random value for each of the salts and the passwords. This
        // is done after assigning the values to attributes, so that no difference among
        // passwords or salts could be generated by the Random rand object.
        rand.nextBytes(saltOne);
        rand.nextBytes(saltTwo);
        rand.nextBytes(passWord1);
        rand.nextBytes(passWord2);

        // Initialize
        this.user1Pass = new UserPassword(saltOne, passWord1);
        this.user2Pass = new UserPassword(saltTwo, passWord2);
    }

    @Test(timeout = 50)
    public void testUserHashPassword(){
        rand.nextBytes(passWord2);
        rand.nextBytes(passWord1);

        assertNotEquals(passWord2, user1Pass.getHash());
        assertEquals(passWord2, user2Pass.getHash());
    }

    @Test(timeout = 50)
    public void testUserSalt(){
        byte[] password1 = {5, 6, 1, 8, 5, 6, 'a', '!', '6', 5};

        rand.nextBytes(password1);
        rand.nextBytes(saltTwo);

        assertNotEquals(password1, user1Pass.getSalt());
        assertEquals(saltTwo, user2Pass.getSalt());

        user1Pass.setSalt(password1);
        assertNotEquals("This is no longer the current salt of this user!",
                saltOne, user1Pass.getSalt());
    }

    @Test(timeout = 50)
    public void testSetHashPassword(){
        byte[] newPass1 = {7, 1, 4};
        rand.nextBytes(newPass1);

        this.user1Pass.setHash(newPass1);
        assertEquals(newPass1, user1Pass.getHash());

        // Not updating the password yet
        byte[] newPass2 = {7, 1, 4, 2};
        rand.nextBytes(newPass2);

        assertNotEquals("The given password is not updated to the given password2 yet!",
                newPass2, user1Pass.getHash());

        // Until now
        user1Pass.setHash(newPass2);
        assertEquals(newPass2, user1Pass.getHash());
    }

    @Test(timeout = 50)
    public void testSetSalt(){
        byte[] newSalt1 = {5, 6, 8, 2, 6, 4, 1, 3};
        rand.nextBytes(newSalt1);

        // Not update the Salt yet
        assertNotEquals("The current salt has not yet been updated to newSalt1!",
                newSalt1, user1Pass.getSalt());

        // Until now
        user1Pass.setSalt(newSalt1);
        assertEquals(newSalt1, user1Pass.getSalt());
    }

    @Test(timeout = 50)
    public void testGetBase64SaltHash(){
        // This test is to highlight the randomness in generating values of Base64, that could
        // generate different values to any value, regardless of their similarity.
        byte[] combined = {5, 6, 8, 2, 6, 4, 1, 5, 6, 1, 8, 5, 6, 'a', '!', 6, 5};
        assertNotEquals(Base64.getEncoder().encodeToString(combined),
                UserPassword.getBase64SaltHash(user1Pass));
    }
}
